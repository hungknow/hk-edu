import type { Collection } from "mongodb";
import { CourseEntity, zCourseEntity } from "../entities";
import type { GetCourseDB } from "./getCourseDB";

export interface CreateCourseEntity {
    (courseData: { title: string; description: string; }): Promise<CourseEntity>
}

export interface BuildCreateCourseEntityParams {
    getCourseDB: GetCourseDB;
}

export function buildCreateCourseEntity({ getCourseDB }: BuildCreateCourseEntityParams): CreateCourseEntity {
    return async (courseData: { title: string; description: string; }): Promise<CourseEntity> => {
        // Map description to name as per MongoDB entity definition
        const entityToInsert = {
            title: courseData.title,
            description: courseData.description,
        };

        // Validate the input using Zod schema (CourseEntitySchema expects _id to be an ObjectId, so we only validate against name and title for now)
        // In a real scenario, the persistence layer should handle the _id generation or expect it to be passed appropriately.
        // For simplicity, we are creating a temporary schema for validation before MongoDB inserts _id.
        const tempSchema = zCourseEntity.pick({ title: true, description: true });
        const validatedEntity = tempSchema.parse(entityToInsert);

        const db = await getCourseDB();
        const collection: Collection<CourseEntity> = db.collection("courses");

        const result = await collection.insertOne(validatedEntity as any); // Type assertion needed because _id is generated by MongoDB

        if (!result.acknowledged) {
            throw new Error("Failed to create course entity");
        }

        // Return the created entity with the _id generated by MongoDB
        return { _id: result.insertedId as any, ...validatedEntity, name: validatedEntity.title };
    }
}
